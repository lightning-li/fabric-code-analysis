#### Next-Consensus-Architecture-Proposal

*本文翻译于 https://github.com/hyperledger-archives/fabric/wiki/Next-Consensus-Architecture-Proposal*

讨论和留言在[这里](http://github.com/hyperledger/fabric/issues/1631)

作者：Elli Androulaki, Christian Cachin, Angelo De Caro, Konstantinos Christidis, Chet Murthy, Binh Nguyen, Alessandro Sorniotti, and Marko Vukolić

本篇记录了区块链基础设施的架构，每一个区块链中的节点角色被划分为 *peers* 角色(维护状态和总账)和 *consenters* 角色(对包含在区块链状态里的交易最终顺序达成共识)。在大部分区块链架构中(包括2016年7月份版本的 Hyperledger fabric)，这些角色是统一的(例如Hyperledger fabric 里的验证节点)。该架构同时引进了 *endorsing peers* ，一种特殊类型的 *peers*，来负责模拟执行和为交易背书(对应于 Hyperledger fabric 0.5 版本中执行和验证交易的行为)。

该架构与以前的设计( peers/consenters/endorsers 是一体的)相比有以下优势：
- **链上编码信任的灵活性(Chaincode trust flexibility)**。该架构使对链上编码的信任假设从对共识的信任假设中分离开来。换一种方式来说，共识服务可以由一系列的节点(consenters)来提供，允许部分节点失败或者有恶意行为；而对于每一个链上编码 endorsers 可以是不同的。

- **可扩展性(Scalability)**。 当负责特指的链上编码的 endorser 节点与 consenters 节点是统计上独立的时候，系统的扩展性相对于全部的功能被相同的节点实现这一方式要更好。尤其是，当不同的链上编码定义了不相交的 endorsers 集合的时候，这样就会产生链上编码之间的分离，可以允许并行的执行链上编码(endorsement)。还会将可能很耗时的链上编码的执行过程也与共识服务过程分离开来。

- **机密性(Confidentiality)**。该架构使得对它所属的交易的内容、状态更新有具体机密性要求的链上编码的部署更加便利。

- **共识模块化(Consensus modularity)**。该架构使模块化的，并且允许可插拨的共识实现。

#### 目录
1. 系统架构
2. 交易背书(endorsement)的基本工作流程
3. 背书原则
4. 区块链数据结构
5. 状态转移与检查点(checkpoint)
6. 机密性

---
#### 1. 系统架构

区块链是一个由许多相互交流的节点组成的分布式系统。区块链运行着称为链上编码的程序，持有状态和总账数据，执行交易。链上编码是关键性元素：交易是一系列在链上编码上唤醒的操作，并且只有链上编码能改变状态。交易必须被认可(背书)，并且只有背书过的交易才能被提交来影响区块链上的状态。可能会存在一个或多个特殊的链上编码来管理函数、参数，这些被称为*系统级链上编码*。

##### 1.1. 交易

交易有以下两种类型：

- *部署交易 (Deploy transactions)* 创建新的链上编码，使用一个程序作为参数。当一个部署交易成功执行后，链上编码就被安装在了区块链上。

- *唤醒交易 (Invoke transactions)* 在某个具体的链上编码中执行具体的操作。一个唤醒交易指向一个链上编码提供的函数。当该交易成功执行后，链上编码会执行相应的函数，该函数可能会修改相应的状态并且返回一个输出。

就像随后描述的那样，部署交易是唤醒交易中一种特殊的类型，因为部署交易会创建新的链上编码，对应于在某一个系统级链上编码的唤醒交易。

**Remark：** *该文献当前假设了一个交易要么创建新的链上编码，要么唤醒已经部署在区块链上的某个链上编码中的某个操作。该文献还没有描述：a)支持跨链上编码的交易，b)查询(read-only)交易的优化。*

##### 1.2. 状态

**区块链状态.** 区块链的状态 (**world state**) 有一个简单的结构，被建模为一个版本化的键值存储 (KVS)，其中，键是名称，值是任意的数据。这些键值对条目被运行在区块链上的链上编码 (应用程序) 通过 `put` 和 `get` KVS 指令操作。状态被持久化的存储，并且对状态的更新操作会被日志记录。注意，版本化的 KVS 是作为一种状态模型适配的，一个具体的实现可以使用实际的 KVSs，但是亦可以是 RDBMS (关系型数据库管理系统) 或者其它的解决方案。

更加正式地，区块链状态 `s` 被建模为映射关系 `K -> (V X N)` 的一个元素：
- `K` 是键的集合
- `V` 是值得集合
- `N` 是一个无限有序的版本号集合。一对一映射函数 `netx : N -> N`，输入 `N` 的一个元素，返回下一个版本号。

`V` 和 `N` 都包含一个特殊的元素 `\bot`，暗示 `N` 中最小的元素。初始的时候，所有的键都被映射到 `(\bot, \bot)`。对于 `s(k)=(v, ver)`，我们通过 `s(k).value` 来表示 `v`，`s(k).version` 来表示 `ver`。

KVS 操作建模为如下：
- `put(k, v)`，
\[a \in b \]
